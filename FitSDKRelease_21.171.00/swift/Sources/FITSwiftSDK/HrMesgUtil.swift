/////////////////////////////////////////////////////////////////////////////////////////////
// Copyright 2025 Garmin International, Inc.
// Licensed under the Flexible and Interoperable Data Transfer (FIT) Protocol License; you
// may not use this file except in compliance with the Flexible and Interoperable Data
// Transfer (FIT) Protocol License.
/////////////////////////////////////////////////////////////////////////////////////////////
// ****WARNING****  This file is auto-generated!  Do NOT edit this file.
// Profile Version = 21.171.0Release
// Tag = production/release/21.171.0-0-g57fed75
/////////////////////////////////////////////////////////////////////////////////////////////


import Foundation

public class HrMesgUtil {
    static let GAP_INCREMENT_MILLISECONDS = 250
    static let GAP_INCREMENT_SECONDS: Double = Double(GAP_INCREMENT_MILLISECONDS) / 1000.0
    static let GAP_MAX_MILLISECONDS = 5000
    static let GAP_MAX_STEPS = GAP_MAX_MILLISECONDS / GAP_INCREMENT_MILLISECONDS
    
    enum HrMesgUtilError: Error {
        case anchorHrMesgMustHave1EventTimestamp
        case noAnchorTimestampReceivedInHRMesgBeforeDeltaHRMesgs
        case hrMesgWithMismatchingEventTimestampAndFilteredBpm
        case anchorEventTimestampIsGreaterThanSubsequentEventTimestamp
    }
    
    class func mergeHeartRates(fitMessages: FitMessages) throws {
        try mergeHeartRates(hrMesgs: fitMessages.hrMesgs, recordMesgs: fitMessages.recordMesgs)
    }
    
    class func mergeHeartRates(hrMesgs: [HrMesg]?, recordMesgs: [RecordMesg]?) throws {
        if (hrMesgs == nil || recordMesgs == nil || hrMesgs?.count == 0 || recordMesgs?.count == 0){
            return
        }
        
        let heartrates = try HrMesgUtil.expandHeartRates(hrMesgs: hrMesgs!)
        
        var heartrateIndex = 0
        var recordRangeStartTime: DateTime? = nil
        
        for recordMesg in recordMesgs! {
            var hrSum: UInt16 = 0
            var hrSumCount: UInt16 = 0
            
            let recordRangeEndTime = recordMesg.getTimestamp()
            
            if (recordRangeStartTime == nil) {
                recordRangeStartTime = recordRangeEndTime
            }
            
            if (recordRangeStartTime == recordRangeEndTime) {
                recordRangeStartTime = DateTime(timestamp: recordRangeStartTime!.timestamp - 1)
                heartrateIndex = (heartrateIndex >= 1) ? heartrateIndex - 1 : 0
            }
            
            var findingInRangeHrMesgs = true
            while (findingInRangeHrMesgs && (heartrateIndex < heartrates.count)) {
                
                let heartrate = heartrates[heartrateIndex]
                
                // Check if the heartrate timestamp is gt record start time
                // and if the heartrate timestamp is lte to record end time
                if (heartrate.timestamp > Double(recordRangeStartTime!.timestamp) && heartrate.timestamp <= Double(recordRangeEndTime!.timestamp)) {
                    hrSum = hrSum + UInt16(heartrate.heartRate)
                    hrSumCount = hrSumCount + 1
                }
                // Check if the heartrate timestamp exceeds the record time
                else if (heartrate.timestamp > Double(recordRangeEndTime!.timestamp)) {
                    findingInRangeHrMesgs = false
                    
                    if (hrSumCount > 0) {
                        // Update record's heart rate value
                        let avgHr: UInt8 = UInt8((Double(hrSum) / Double(hrSumCount)).rounded())
                        try recordMesg.setHeartRate(avgHr)
                    }
                    // Reset HR average accumulators
                    hrSum = 0
                    hrSumCount = 0
                    
                    recordRangeStartTime = recordRangeEndTime
                    
                    // Breaks out of findingInRangeHrMesgs while loop w/o incrementing heartrateIndex
                    break
                }
                heartrateIndex = heartrateIndex + 1
            }
        }
    }
    
    class func expandHeartRates(hrMesgs: [HrMesg]) throws -> [(timestamp: Float64, heartRate: UInt8)] {
        var anchorEventTimestamp: Float64? = 0
        var anchorTimestamp: Float64? = nil
        
        var heartrates: [(timestamp: Float64, heartRate: UInt8)] = []
        
        for hrMesg in hrMesgs {
            let eventTimestamps: [Float64?]? = hrMesg.getEventTimestamp()
            let filteredBpms: [UInt8?]? = hrMesg.getFilteredBpm()
            
            // Update HR timestamp anchor, if present
            if (hrMesg.getTimestamp() != nil) {
                anchorTimestamp = Float64(fitValue: hrMesg.getTimestamp()!.timestamp)
                
                if (hrMesg.getFractionalTimestamp() != nil) {
                    anchorTimestamp = Float64(fitValue: anchorTimestamp) + hrMesg.getFractionalTimestamp()!
                }
                
                if (eventTimestamps!.count == 1) {
                    anchorEventTimestamp = eventTimestamps![0]
                }
                else {
                    throw HrMesgUtilError.anchorHrMesgMustHave1EventTimestamp
                }
            }
            
            if (anchorTimestamp == nil || anchorEventTimestamp == nil) {
                // We cannot process any HR messages if we have not received a timestamp anchor
                throw HrMesgUtilError.noAnchorTimestampReceivedInHRMesgBeforeDeltaHRMesgs
            }
            else if (eventTimestamps!.count != filteredBpms!.count) {
                throw HrMesgUtilError.hrMesgWithMismatchingEventTimestampAndFilteredBpm
            }
            
            for (index, var eventTimestamp) in eventTimestamps!.enumerated() {
                // Check to see if the event timestamp rolled over
                if (eventTimestamp! < anchorEventTimestamp!) {
                    if ((anchorEventTimestamp! - eventTimestamp!) > (0x400000)) {
                        eventTimestamp = eventTimestamp! + 0x400000
                    }
                    else {
                        throw HrMesgUtilError.anchorEventTimestampIsGreaterThanSubsequentEventTimestamp
                    }
                }
                
                var currentHr: (timestamp: Float64, heartRate: UInt8) = (anchorTimestamp!, filteredBpms![index]!)
                currentHr.timestamp = currentHr.timestamp + (eventTimestamp! - anchorEventTimestamp!)
                
                // Carry the previous HR value forward across the gap to the current
                // HR value for up to 5 Seconds (5000ms) in 250ms increments
                if (heartrates.count > 0) {
                    let previousHr = heartrates[heartrates.count - 1]
                    var gapInMilliseconds: Double = abs(currentHr.timestamp - previousHr.timestamp) * 1000
                    var step = 1
                    while (gapInMilliseconds > Double(GAP_INCREMENT_MILLISECONDS) && step <= GAP_MAX_STEPS) {
                        var gapHr: (timestamp: Float64, heartRate: UInt8) = (previousHr.timestamp, previousHr.heartRate)
                        gapHr.timestamp = gapHr.timestamp + (GAP_INCREMENT_SECONDS * Double(step))
                        heartrates.append(gapHr)
                        
                        gapInMilliseconds = gapInMilliseconds - Double(GAP_INCREMENT_MILLISECONDS)
                        step = step + 1
                    }
                }
                heartrates.append(currentHr)
            }
        }
        return heartrates
    }
}
