/////////////////////////////////////////////////////////////////////////////////////////////
// Copyright 2025 Garmin International, Inc.
// Licensed under the Flexible and Interoperable Data Transfer (FIT) Protocol License; you
// may not use this file except in compliance with the Flexible and Interoperable Data
// Transfer (FIT) Protocol License.
/////////////////////////////////////////////////////////////////////////////////////////////
// ****WARNING****  This file is auto-generated!  Do NOT edit this file.
// Profile Version = 21.171.0Release
// Tag = production/release/21.171.0-0-g57fed75
/////////////////////////////////////////////////////////////////////////////////////////////


import Foundation

open class Mesg: Equatable {
    public let name: String
    public let mesgNum: UInt16
    public internal(set)var localMesgNum: LocalMesgNum = LocalMesgNum.zero
    public internal(set)var decoderMesgIndex: Int = 0
    
    var fields: [UInt8: Field] = [:]
    var devFields: [DeveloperDataKey:DeveloperField] = [:]

    enum MesgError: Error {
        case subFieldNotSupported
        case typeNotSupported
    }
    
    public init(mesg: Mesg) {
        self.name = mesg.name
        self.mesgNum = mesg.mesgNum
        self.localMesgNum = mesg.localMesgNum
        self.decoderMesgIndex = mesg.decoderMesgIndex

        
        for (num, field) in mesg.fields {
            if(field.hasValues) {
                fields[num] = Field(field: field)
            }
        }
        
        for developerField in mesg.devFields {
            if (developerField.value.hasValues) {
                devFields[developerField.key] = developerField.value
            }
        }
    }
    
    public init(name: String, num: UInt16) {
        self.name = name
        self.mesgNum = num
    }
    
    func read(stream: InputStream, mesgDefinition: MesgDefinition, accumulator: Accumulator) throws {
        for fieldDefinition in mesgDefinition.fieldDefinitions {
            var field = getField(fieldNum: fieldDefinition.num)
            
            if (field == nil) {
                // The field is not in the profile, so create a default Field based on the num and type
                field = Factory.createDefaultField(fieldNum: fieldDefinition.num, baseType: fieldDefinition.baseType)
                
                fields[fieldDefinition.num] = field
            }
            
            
            try field!.read(stream: stream, size: fieldDefinition.size, endianness: mesgDefinition.endianness)

            if(field!.accumulated) {
                setAccumulatedField(field: field!, accumulator: accumulator)
            }
        }
        
        try fields.forEach { try expandComponents(containingField: $0.value, accumulator: accumulator) }
        
        for developerFieldDefinition in mesgDefinition.developerFieldDefinitions {
            if(developerFieldDefinition.developerDataIdMesg == nil || developerFieldDefinition.fieldDescriptionMesg == nil) {
                return
            }
            var devField = getDeveloperField(developerDataIdMesg: developerFieldDefinition.developerDataIdMesg!, fieldDescriptionMesg: developerFieldDefinition.fieldDescriptionMesg!)
            
            if (devField == nil) {
                devField = DeveloperField(def: developerFieldDefinition)
                setDeveloperField(devField!)
            }
            
            try devField!.read(stream: stream, size: developerFieldDefinition.size, endianness: mesgDefinition.endianness)
        }
    }
    
    // MARK: Accumulation
    
    func setAccumulatedField(field: Field, accumulator: Accumulator) {
        for index in 0..<Int(field.numValues) {
            var value = field.getRawValue(index: index)
            
            for containingField in fields {
                for component in containingField.value.components {
                    if(component.fieldNum == field.num && component.accumulated) {
                        value = (((Float64(fitValue: value) / field.scale) - field.offset) + component.offset) * component.scale
                    }
                }
            }
            
            accumulator.createAccumulatedField(mesgNum: mesgNum, fieldNum: field.num, value: Int64(fitValue: value))
        }
    }
    
    // MARK: Component Expansion
    
    func expandComponents(containingField: Field, accumulator: Accumulator) throws {
        if(!containingField.hasValues) {
            return
        }
        
        var components: [FieldComponent] = []
        
        // Check for active subfield components
        let activeSubfieldIndex = try getActiveSubFieldIndex(fieldNum: containingField.num)
        let activeSubfield = containingField.getSubField(subFieldIndex: Int(activeSubfieldIndex))
        
        if (activeSubfieldIndex == FIT.SUBFIELD_INDEX.MAIN_FIELD && containingField.hasComponents) {
            components = containingField.components
        }
        else if (activeSubfield != nil && activeSubfield!.hasComponents) {
            components = containingField.subFields[Int(activeSubfieldIndex)].components
        }
        
        if (components.count == 0) {
            return
        }
        
        let bitstream = try BitStream(values: containingField.values as! [any Numeric])
        
        for component in components {
            if(bitstream.bitsAvailable < component.bits) {
                break
            }
            
            var value = try bitstream.readBits(component.bits)
            
            let componentField = try fields[component.fieldNum] ?? createNewFieldOrDefaultField(fieldNum: component.fieldNum, value: value)
            componentField.isExpandedField = true
            
            
            if(component.accumulated) {
                value = accumulator.accumulate(mesgNum: mesgNum, fieldNum: component.fieldNum, value: value, bits: component.bits)
            }
            
            // Undo component scale and offset before applying the destination field's scale and offset
            let scale: Float64 = activeSubfield != nil ? activeSubfield!.scale : componentField.scale
            let offset: Float64 = activeSubfield != nil ? activeSubfield!.offset : componentField.offset
            
            let scaledValue: Float64 = (((Float64(fitValue: value) / component.scale) - component.offset) + offset) * scale
            try componentField.addRawValue(scaledValue)
            
            fields[component.fieldNum] = componentField
            
            // Expand any components in the new field
            if(componentField.hasComponents) {
                try expandComponents(containingField: componentField, accumulator: accumulator)
            }
        }
    }
    
    public func removeExpandedFields() {
        fields = fields.filter { !$0.value.isExpandedField }
    }
    
    // MARK: Get Fields
    
    var fieldCount: Int {
        return fields.count
    }

    public func getFields() -> [Field] {
        return Array(fields.values)  
    }

    public func getField(fieldNum: UInt8) -> Field? {
        guard let field = fields[fieldNum] else {
            return nil
        }
        
        return field
    }
    
    public func getField(fieldName: String) -> Field? {
        let element = fields.first(where: {
            return $0.value.name == fieldName
        })
        
        return element?.value
    }
    
    public func getActiveSubFieldIndex(fieldNum: UInt8) throws -> UInt16 {
        guard let testField = getField(fieldNum: fieldNum) else {
            return FIT.SUBFIELD_INDEX.MAIN_FIELD
        }
    
        for (index, subField) in testField.subFields.enumerated() {
            if (try subField.canMesgSupport(mesg: self)) {
                return UInt16(index)
            }
        }
        return FIT.SUBFIELD_INDEX.MAIN_FIELD
    }

    public func hasField(fieldNum: UInt8) -> Bool {
        return getField(fieldNum: fieldNum) != nil
    }

    // MARK: Set Field

    public func setField(field: Field) {
        fields.updateValue(field, forKey: field.num)
    }

    public func setFields(mesg: Mesg) {
        if (mesg.mesgNum != mesgNum) {
            return
        }

        mesg.fields.forEach { (fieldNum, field) in
            setField(field: field)
        }
    }

    // MARK: Remove Fields

    public func removeField(field: Field) {
        removeField(fieldNum: field.num)
    }

    public func removeField(fieldNum: UInt8) {
        fields.removeValue(forKey: fieldNum)
    }

    // MARK: Get Field Values
    
    public func getFieldValue(fieldNum: UInt8) -> Any? {
        return getFieldValue(fieldNum: fieldNum, index: 0)
    }
    
    public func getFieldValue(fieldNum: UInt8, index: Int) -> Any? {
        return fields[fieldNum]?.getValue(index: index, subField: nil)
    }
    
    public func getFieldValue(fieldNum: UInt8, index: Int, subFieldIndex: UInt16) throws -> Any? {
        let field = fields[fieldNum]
        
        if (field == nil) {
            return nil;
        }
        
        if (subFieldIndex == FIT.SUBFIELD_INDEX.ACTIVE_SUBFIELD) {
            return try field?.getValue(index: index, subFieldIndex: getActiveSubFieldIndex(fieldNum: fieldNum))
        }
        else {
            let subField = field?.getSubField(subFieldIndex: Int(subFieldIndex))
            
            if try ((subField == nil) || (subField!.canMesgSupport(mesg: self))){
                return try field?.getValue(index: index, subFieldIndex: subFieldIndex)
            }
            else {
                return nil
            }
        }
    }
    
    // MARK: Set Field Values
    
    public func setFieldValue(fieldNum: UInt8, value: Any?) throws {
        try setFieldValue(fieldNum: fieldNum, value: value, index: 0)
    }

    public func setFieldValue(fieldNum: UInt8, value: Any?, index: Int) throws {
        try setFieldValue(fieldNum: fieldNum, value: value, index: index, subFieldIndex: FIT.SUBFIELD_INDEX.MAIN_FIELD)
    }

    public func setFieldValue(fieldNum: UInt8, value: Any?, index: Int, subFieldIndex: UInt16) throws {
            var field = getField(fieldNum: fieldNum)
            
            if (field == nil) {
                field = try createNewFieldOrDefaultField(fieldNum: fieldNum, value: value)
                
                fields[fieldNum] = field
            }
            
            let subField = field?.getSubField(subFieldIndex: Int(subFieldIndex))
            
            if (subField != nil) {
                if try (!subField!.canMesgSupport(mesg: self)){
                    throw MesgError.subFieldNotSupported
                }
            }
            
            try field!.setValue(index: index, value: value, subFieldIndex: subFieldIndex)
    }

    // MARK: Developer Fields
    
    var devFieldCount: Int {
        return devFields.count
    }
    
    public var developerFields: [DeveloperField] {
        return Array(devFields.values)
    }
    
    public func setDeveloperField(_ field: DeveloperField) {
        let developerDataKey = DeveloperDataKey(developerDataIdMesg: field.developerFieldDefinition.developerDataIdMesg!, fieldDescriptionMesg: field.developerFieldDefinition.fieldDescriptionMesg!)
        
        devFields[developerDataKey!] = field
    }
    
    func getDeveloperField(developerDataIdMesg: DeveloperDataIdMesg, fieldDescriptionMesg: FieldDescriptionMesg) -> DeveloperField? {
        guard let developerDataKey = DeveloperDataKey(developerDataIdMesg: developerDataIdMesg, fieldDescriptionMesg: fieldDescriptionMesg) else {
            return nil
        }
        
        return devFields.contains{ $0.key == developerDataKey } ? devFields[developerDataKey] : nil
    }
    
    public func write(outputStream: OutputStream, mesgDefinition: MesgDefinition) {
        let headerByte: UInt8 = localMesgNum.rawValue & FIT.HDR_TYPE_MASK
        outputStream.append(value: headerByte)
        
        for fieldDefinition in mesgDefinition.fieldDefinitions {
            let field = self.getField(fieldNum: fieldDefinition.num)
            field?.write(outputStream: outputStream)
        }

        for developerField in devFields.values {            
            developerField.write(outputStream: outputStream)
        }
    }
    
    func createNewFieldOrDefaultField(fieldNum: UInt8, value: Any?) throws -> Field {
        guard let field = Factory.createField(mesgNum: mesgNum, fieldNum: fieldNum) else {
            guard let baseType = BaseType.from(value) else {
                throw MesgError.typeNotSupported
            }
            
            return Factory.createDefaultField(fieldNum: fieldNum, baseType: baseType)
        }
        
        return field
    }
    
    // MARK: Equatable
    
    public static func == (lhs: Mesg, rhs: Mesg) -> Bool {
        return lhs.mesgNum == rhs.mesgNum &&
        lhs.localMesgNum == rhs.localMesgNum &&
        lhs.decoderMesgIndex == rhs.decoderMesgIndex &&
        lhs.fields.count == rhs.fields.count &&
        lhs.devFields.count == rhs.devFields.count &&
        lhs.name == rhs.name &&
        lhs.fields == rhs.fields &&
        lhs.devFields == rhs.devFields
    }
}
