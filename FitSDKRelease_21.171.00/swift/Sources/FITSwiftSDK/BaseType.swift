/////////////////////////////////////////////////////////////////////////////////////////////
// Copyright 2025 Garmin International, Inc.
// Licensed under the Flexible and Interoperable Data Transfer (FIT) Protocol License; you
// may not use this file except in compliance with the Flexible and Interoperable Data
// Transfer (FIT) Protocol License.
/////////////////////////////////////////////////////////////////////////////////////////////
// ****WARNING****  This file is auto-generated!  Do NOT edit this file.
// Profile Version = 21.171.0Release
// Tag = production/release/21.171.0-0-g57fed75
/////////////////////////////////////////////////////////////////////////////////////////////


import Foundation

public enum BaseType: UInt8, CaseIterable {
    case ENUM = 0x00
    case SINT8 = 0x01
    case UINT8 = 0x02
    case SINT16 = 0x83
    case UINT16 = 0x84
    case SINT32 = 0x85
    case UINT32 = 0x86
    case STRING = 0x07
    case FLOAT32 = 0x88
    case FLOAT64 = 0x89
    case UINT8Z = 0x0A
    case UINT16Z = 0x8B
    case UINT32Z = 0x8C
    case BYTE = 0x0D
    case SINT64 = 0x8E
    case UINT64 = 0x8F
    case UINT64Z = 0x90
    
    var size: UInt8 {
        switch self {
        case .ENUM: 1
        case .SINT8: 1
        case .UINT8: 1
        case .SINT16: 2
        case .UINT16: 2
        case .SINT32: 4
        case .UINT32: 4
        case .STRING: 1
        case .FLOAT32: 4
        case .FLOAT64: 8
        case .UINT8Z: 1
        case .UINT16Z: 2
        case .UINT32Z: 4
        case .BYTE: 1
        case .SINT64: 8
        case .UINT64: 8
        case .UINT64Z: 8
        }
    }

    static func from(_ value: Any?) -> BaseType? {
        switch value {
        case _ as UInt8, _ as Bool: .UINT8
        case _ as Int8: .SINT8
        case _ as UInt16: .UINT16
        case _ as Int16: .SINT16
        case _ as UInt32: .UINT32
        case _ as Int32: .SINT32
        case _ as UInt64: .UINT64
        case _ as Int64: .SINT64
        case _ as Float32: .FLOAT32
        case _ as Float64: .FLOAT64
        case _ as String: .STRING
        default: nil
        }
    }

    var isNumeric: Bool {
        switch self {
        case .ENUM, .STRING: false
        default: true
        }
    }

    var isFloatingPoint: Bool {
        switch self {
        case .FLOAT32, .FLOAT64: true
        default: false
        }
    }

    func isInvalid(_ value: Any?) -> Bool {
        return !isValid(value)
    }
    
    func isValid(_ value: Any?) -> Bool {
        guard let value else {
            return false
        }

        return switch self {
        case .ENUM: correctRangeAndType(value) as! UInt8 != invalidValue()
        case .SINT8: correctRangeAndType(value) as! Int8 != invalidValue()
        case .UINT8: correctRangeAndType(value) as! UInt8 != invalidValue()
        case .SINT16: correctRangeAndType(value) as! Int16 != invalidValue()
        case .UINT16: correctRangeAndType(value) as! UInt16 != invalidValue()
        case .SINT32: correctRangeAndType(value) as! Int32 != invalidValue()
        case .UINT32: correctRangeAndType(value) as! UInt32 != invalidValue()
        case .STRING: {
            let string = String(anyValue:  value)
            return string.utf8.count <= FIT.STRING_MAX_BYTE_COUNT && string.trimTrailingNullTerminators().count > 0
        }()
        case .FLOAT32: !Float32(fitValue: value).isNaN
        case .FLOAT64: !Float64(fitValue: value).isNaN
        case .UINT8Z: correctRangeAndType(value) as! UInt8 != invalidValue()
        case .UINT16Z: correctRangeAndType(value) as! UInt16 != invalidValue()
        case .UINT32Z: correctRangeAndType(value) as! UInt32 != invalidValue()
        case .BYTE: correctRangeAndType(value) as! UInt8 != invalidValue()
        case .SINT64: correctRangeAndType(value) as! Int64 != invalidValue()
        case .UINT64: correctRangeAndType(value) as! UInt64 != invalidValue()
        case .UINT64Z: correctRangeAndType(value) as! UInt64 != invalidValue()
        }
    }
    
    var invalidBytes: [UInt8] {
        switch self {
        case .ENUM: UInt8.max.bytes
        case .SINT8: Int8.max.bytes
        case .UINT8: UInt8.max.bytes
        case .SINT16: Int16.max.bytes
        case .UINT16: UInt16.max.bytes
        case .SINT32: Int32.max.bytes
        case .UINT32: UInt32.max.bytes
        case .STRING: [0x00]
        case .FLOAT32:  UInt32.max.bytes
        case .FLOAT64: UInt64.max.bytes
        case .UINT8Z: UInt8(0x00).bytes
        case .UINT16Z: UInt16(0x0000).bytes
        case .UINT32Z: UInt32(0x00000000).bytes
        case .BYTE: UInt8(0xFF).bytes
        case .SINT64: Int64.max.bytes
        case .UINT64: UInt64.max.bytes
        case .UINT64Z: UInt64(0x0000000000000000).bytes
        }
    }

    func invalidValue<T>() -> T {
        return invalidValueInternal() as! T
    }

    internal func invalidValueInternal() -> Any {
        switch self {
        case .ENUM: return UInt8.max
        case .SINT8: return Int8.max
        case .UINT8: return UInt8.max
        case .SINT16: return Int16.max
        case .UINT16: return UInt16.max
        case .SINT32: return Int32.max
        case .UINT32: return UInt32.max
        case .STRING: return 0x00
        case .FLOAT32: return Float32.nan
        case .FLOAT64: return Float64.nan
        case .UINT8Z: return UInt8.min
        case .UINT16Z: return UInt16.min
        case .UINT32Z: return UInt32.min
        case .BYTE: return UInt8.max
        case .SINT64: return Int64.max
        case .UINT64: return UInt64.max
        case .UINT64Z: return UInt64.min
        }
    }

    private var min: Float64? {
        switch self {
        case .ENUM: Float64(UInt8.min)
        case .SINT8: Float64(Int8.min)
        case .UINT8: Float64(UInt8.min)
        case .SINT16: Float64(Int16.min)
        case .UINT16: Float64(UInt16.min)
        case .SINT32: Float64(Int32.min)
        case .UINT32: Float64(UInt32.min)
        case .STRING: nil
        case .FLOAT32: Float64(fitValue: -Float32.greatestFiniteMagnitude)
        case .FLOAT64: -Float64.greatestFiniteMagnitude
        case .UINT8Z: Float64(UInt8.min)
        case .UINT16Z: Float64(UInt16.min)
        case .UINT32Z: Float64(UInt32.min)
        case .BYTE: Float64(UInt8.min)
        case .SINT64: Float64(Int64.min)
        case .UINT64: Float64(UInt64.min)
        case .UINT64Z: Float64(UInt64.min)
        }
    }
    
    private var max: Float64? {
        switch self {
        case .ENUM: Float64(UInt8.max)
        case .SINT8: Float64(Int8.max)
        case .UINT8: Float64(UInt8.max)
        case .SINT16: Float64(Int16.max)
        case .UINT16: Float64(UInt16.max)
        case .SINT32: Float64(Int32.max)
        case .UINT32: Float64(UInt32.max)
        case .STRING: nil
        case .FLOAT32: Float64(fitValue: Float32.greatestFiniteMagnitude)
        case .FLOAT64: Float64.greatestFiniteMagnitude
        case .UINT8Z: Float64(UInt8.max)
        case .UINT16Z: Float64(UInt16.max)
        case .UINT32Z: Float64(UInt32.max)
        case .BYTE: Float64(UInt8.max)
        case .SINT64: Float64(Int64.max)
        case .UINT64: Float64(UInt64.max)
        case .UINT64Z: Float64(UInt64.max)
        }
    }
    
    
    var profileType: Profile.ProfileType {
        switch self {
        case .ENUM: .enum
        case .SINT8: .sint8
        case .UINT8: .uint8
        case .SINT16: .sint16
        case .UINT16: .uint16
        case .SINT32: .sint32
        case .UINT32: .uint32
        case .STRING: .string
        case .FLOAT32: .float32
        case .FLOAT64: .float64
        case .UINT8Z: .uint8z
        case .UINT16Z: .uint16z
        case .UINT32Z: .uint32z
        case .BYTE: .uint8
        case .SINT64: .sint64
        case .UINT64: .uint64
        case .UINT64Z: .uint64z
        }
    }

    func correctRangeAndType(_ value: Any) -> Any? {
        var doubleValue = Float64()
        if (min != nil && max != nil) {
            doubleValue = Float64(fitValue: value)
            
            if (doubleValue.isNaN || doubleValue.isInfinite || doubleValue < min! || doubleValue > max!
                || doubleValue == Float64(fitValue: invalidValue() as Any))
            {
                return invalidValue()
            }
        }

        return switch self {
        case .ENUM: UInt8(fitValue: doubleValue)
        case .SINT8: Int8(fitValue: doubleValue)
        case .UINT8: UInt8(fitValue: doubleValue)
        case .SINT16: Int16(fitValue: doubleValue)
        case .UINT16: UInt16(fitValue: doubleValue)
        case .SINT32: Int32(fitValue: doubleValue)
        case .UINT32: UInt32(fitValue: doubleValue)
        case .FLOAT32: Float32(fitValue: doubleValue)
        case .FLOAT64: Float64(fitValue: doubleValue)
        case .UINT8Z: UInt8(fitValue: doubleValue)
        case .UINT16Z: UInt16(fitValue: doubleValue)
        case .UINT32Z: UInt32(fitValue: doubleValue)
        case .BYTE: UInt8(fitValue: doubleValue)
        case .SINT64: Int64(fitValue: doubleValue)
        case .UINT64: UInt64(fitValue: doubleValue)
        case .UINT64Z: UInt64(fitValue: doubleValue)
        case .STRING: String(anyValue: value)
        }
    }
}
